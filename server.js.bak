const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const multer = require('multer');
const path = require('path');
const fs = require('fs');

const app = express();
const server = http.createServer(app);
const io = new Server(server);

// Middleware
app.use(express.static('public'));
app.use('/uploads', express.static('uploads'));
app.use(express.json());

// Multer for photo upload
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const dest = path.join(__dirname, 'uploads');
    if (!fs.existsSync(dest)) fs.mkdirSync(dest, { recursive: true });
    cb(null, dest);
  },
  filename: (req, file, cb) => {
    cb(null, file ? `${Date.now()}${path.extname(file.originalname || '.png')}` : '');
  }
});
const upload = multer({ storage });

// Read player and team data with normalization
let players = [];
let teams = [];
let teamLogos = {};
try {
  players = JSON.parse(fs.readFileSync(path.join(__dirname, 'data', 'players.json'), 'utf8')).map(p => ({
    ...p,
    name: p.name.trim(),
    photo: p.photo || 'https://via.placeholder.com/200'
  }));
  console.log('Successfully loaded players.json:', players.length, 'players');
} catch (err) {
  console.error('Error reading players.json:', err.message);
  players = [];
}

try {
  const teamData = JSON.parse(fs.readFileSync(path.join(__dirname, 'data', 'teams.json'), 'utf8'));
  teams = teamData.map(team => team.name.trim());
  teamLogos = teamData.reduce((acc, team) => ({
    ...acc,
    [team.name.trim()]: team.logo.trim()
  }), {});
  console.log('Successfully loaded teams.json:', teams.length, 'teams');
} catch (err) {
  console.error('Error reading teams.json:', err.message);
  teams = [];
  teamLogos = {};
}

// Teams with budgets and rosters
let teamBudgets = teams.reduce((acc, team) => ({ ...acc, [team]: 10000 }), {});
let teamRosters = teams.reduce((acc, team) => ({ ...acc, [team]: [] }), {});

// Auction state
let auctionState = {
  name: '',
  role: '',
  photo: 'https://via.placeholder.com/600',
  basePrice: 0,
  currentPrice: 0,
  isBidding: false,
  isSold: false,
  isUnsold: false,
  finalPrice: 0,
  soldTeam: '',
  teamBudgets,
  teamRosters,
  teamLogos
};

// Load or initialize history
let history = [];
try {
  history = JSON.parse(fs.readFileSync(path.join(__dirname, 'data', 'history.json'), 'utf8'));
  if (!Array.isArray(history)) history = [];
} catch (err) {
  console.error('Error reading history.json, initializing empty:', err.message);
  history = [];
}

// Routes
app.get('/', (req, res) => res.sendFile(path.join(__dirname, 'public', 'display.html')));
app.get('/control', (req, res) => res.sendFile(path.join(__dirname, 'public', 'control.html')));
app.get('/players', (req, res) => res.json(players.length ? players : []));
app.get('/sold-players', (req, res) => res.json(Object.values(teamRosters).flat()));

app.post('/start', upload.single('photo'), (req, res) => {
  const { name } = req.body || {};
  const player = players.find(p => p.name.trim() === name?.trim());
  if (!player) return res.status(400).json({ error: 'Player not found!' });
  auctionState = {
    name: player.name,
    role: player.role,
    photo: req.file ? `/uploads/${req.file.filename}` : player.photo,
    basePrice: player.basePrice,
    currentPrice: player.basePrice,
    isBidding: true,
    isSold: false,
    isUnsold: false,
    finalPrice: 0,
    soldTeam: '',
    teamBudgets,
    teamRosters,
    teamLogos
  };
  history.push({ action: 'start', player: player.name, timestamp: new Date().toISOString() });
  fs.writeFileSync(path.join(__dirname, 'data', 'history.json'), JSON.stringify(history, null, 2));
  io.emit('update', auctionState);
  res.json({ success: true });
});

app.post('/increment', (req, res) => {
  if (!auctionState.isBidding || auctionState.isSold) return res.status(400).json({ error: auctionState.isSold ? 'Player already sold!' : 'No active bidding!' });
  const oldPrice = auctionState.currentPrice;
  auctionState.currentPrice += 50;
  history.push({ action: 'increment', oldPrice, newPrice: auctionState.currentPrice, timestamp: new Date().toISOString() });
  fs.writeFileSync(path.join(__dirname, 'data', 'history.json'), JSON.stringify(history, null, 2));
  io.emit('update', auctionState);
  res.json({ success: true });
});

app.post('/sold', (req, res) => {
  const { team } = req.body || {};
  const normalizedTeam = team?.trim();
  if (!normalizedTeam || !teams.includes(normalizedTeam)) return res.status(400).json({ error: `Invalid team! Available teams: ${teams.join(', ')}` });
  if (teamRosters[normalizedTeam].length >= 11) return res.status(400).json({ error: `${normalizedTeam} has reached the maximum of 11 players!` });
  if (teamBudgets[normalizedTeam] < auctionState.currentPrice) return res.status(400).json({ error: `${normalizedTeam} has insufficient budget!` });
  if (!auctionState.isBidding) return res.status(400).json({ error: 'No active bidding!' });

  auctionState.isBidding = false;
  auctionState.isSold = true;
  auctionState.isUnsold = false;
  auctionState.finalPrice = auctionState.currentPrice;
  auctionState.soldTeam = normalizedTeam;

  teamBudgets[normalizedTeam] -= auctionState.finalPrice;

  // ðŸ”¹ PATCHED: store full player object with role + price
  teamRosters[normalizedTeam].push(auctionState.name); // keep only name

history.push({
  action: 'sold',
  player: auctionState.name,
  role: auctionState.role,
  team: auctionState.soldTeam,
  finalPrice: auctionState.finalPrice,
  timestamp: new Date().toISOString()
});

  // ðŸ”¹ PATCHED: also include role in history
  history.push({
    action: 'sold',
    player: auctionState.name,
    role: auctionState.role,
    team: auctionState.soldTeam,
    finalPrice: auctionState.finalPrice,
    timestamp: new Date().toISOString()
  });

  fs.writeFileSync(path.join(__dirname, 'data', 'history.json'), JSON.stringify(history, null, 2));
  io.emit('update', auctionState);
  res.json({ success: true });
});

app.post('/unsold', (req, res) => {
  if (!auctionState.isBidding) return res.status(400).json({ error: 'No active bidding to mark as unsold!' });
  auctionState.isBidding = false;
  auctionState.isUnsold = true;
  history.push({ action: 'unsold', player: auctionState.name, timestamp: new Date().toISOString() });
  fs.writeFileSync(path.join(__dirname, 'data', 'history.json'), JSON.stringify(history, null, 2));
  io.emit('update', auctionState);
  res.json({ success: true });
});

app.post('/undo', (req, res) => {
  if (history.length === 0) return res.status(400).json({ error: 'No actions to undo!' });
  const lastAction = history.pop();
  const { action } = lastAction;

  if (action === 'sold') {
    const { player, team, finalPrice } = lastAction;
    const normalizedTeam = team.trim();
    const teamRoster = teamRosters[normalizedTeam];
    const index = teamRoster.findIndex(p => p.name === player);
    if (index !== -1) teamRoster.splice(index, 1);
    teamBudgets[normalizedTeam] += finalPrice;
    auctionState.isBidding = true; // Restore bidding state
    auctionState.isSold = false;
    auctionState.isUnsold = false;
    auctionState.currentPrice = finalPrice; // Restore last bidding price
    auctionState.finalPrice = 0;
    auctionState.soldTeam = '';
  } else if (action === 'increment') {
    auctionState.currentPrice = lastAction.oldPrice;
    auctionState.isBidding = true;
    auctionState.isSold = false;
    auctionState.isUnsold = false;
  } else if (action === 'start') {
    auctionState = {
      name: '',
      role: '',
      photo: 'https://via.placeholder.com/600',
      basePrice: 0,
      currentPrice: 0,
      isBidding: false,
      isSold: false,
      isUnsold: false,
      finalPrice: 0,
      soldTeam: '',
      teamBudgets,
      teamRosters,
      teamLogos
    };
  } else if (action === 'unsold') {
    auctionState.isBidding = true;
    auctionState.isUnsold = false;
  }

  fs.writeFileSync(path.join(__dirname, 'data', 'history.json'), JSON.stringify(history, null, 2));
  io.emit('update', auctionState);
  res.json({ success: true });
});

app.post('/reset', (req, res) => {
  teamBudgets = teams.reduce((acc, team) => ({ ...acc, [team]: 10000 }), {});
  teamRosters = teams.reduce((acc, team) => ({ ...acc, [team]: [] }), {});
  history = [];
  fs.writeFileSync(path.join(__dirname, 'data', 'history.json'), JSON.stringify(history, null, 2));
  auctionState = {
    name: '',
    role: '',
    photo: 'https://via.placeholder.com/600',
    basePrice: 0,
    currentPrice: 0,
    isBidding: false,
    isSold: false,
    isUnsold: false,
    finalPrice: 0,
    soldTeam: '',
    teamBudgets,
    teamRosters,
    teamLogos
  };
  io.emit('update', auctionState);
  res.json({ success: true });
});

io.on('connection', (socket) => {
  console.log('Client connected');
  socket.emit('update', auctionState);

  socket.on('disconnect', () => console.log('Client disconnected'));

  // ðŸ”¹ PATCHED: use full objects from teamRosters, no need to rely on history
  socket.on('showPlayerChart', ({ team }) => {
  const playerNames = auctionState.teamRosters[team] || [];
  const teamLogo = auctionState.teamLogos[team] || '';
  const purchased = playerNames.map((pName, idx) => {
    const record = history.find(h => h.player === pName && h.team === team && h.action === 'sold');
    return {
      serial: idx + 1,
      name: pName,
      role: record?.role || '',
      price: record?.finalPrice || 0
    };
  });
  io.emit('displayPlayerChart', {
    team,
    logo: teamLogo,
    purchased
  });
});

server.listen(3000, () => console.log('Server running on http://localhost:3000'));